#!/usr/bin/env python

import gtk
import os
import sys
import commands
import subprocess
import time
import signal

# Internationalization
import locale
import gettext
import gtk.glade
gettext.bindtextdomain("gslackbuild", "/usr/share/locale")
gettext.textdomain("gslackbuild")
gettext.install("gslackbuild", "/usr/share/locale", unicode=1)
gtk.glade.bindtextdomain("gslackbuild", "/usr/share/locale")
gtk.glade.textdomain("gslackbuild")


# the config_file will probably only be used for remembering the window
# size
config_file = 'gslackbuild.conf'

# Icons locations should be changed before final release
class Icon:
	avail = gtk.gdk.pixbuf_new_from_file('icons/pkg_action_available.png')
	installed = gtk.gdk.pixbuf_new_from_file('icons/pkg_action_installed.png')
	install = gtk.gdk.pixbuf_new_from_file('icons/pkg_action_install.png')
	reinstall = gtk.gdk.pixbuf_new_from_file('icons/pkg_action_reinstall.png')
	remove = gtk.gdk.pixbuf_new_from_file('icons/pkg_action_remove.png')

class PkgAction:
	DoNothing = 0
	Install = 1
	Reinstall = 2
	Remove = 3

class GSlackBuild:
	def slaptsrclist(self, searchstring):
		if len(searchstring) == 0:
			cmd = 'slapt-src --list'
		else:
			cmd = 'slapt-src -s "'+searchstring+'"'
		status, pkglist_output = commands.getstatusoutput(cmd)
		pkglist_lines = pkglist_output.splitlines()
		pkglist = []
		if status == 0:
			for i in pkglist_lines:
				nameandver, sep, desc = i.partition(' - ')
				name = nameandver.rpartition(':')[0]
				ver = nameandver.rpartition(':')[2]
				pkglist.append([name, ver, desc])
				#make a check if a package with the same version
				#is present in more than one repos. only the
				#first one should be shown
		return status, pkglist

	def refresh_pkglist(self):
		global pending
		global pkg_varlogpkg
		self.ls_pkg.clear()
		# The list is cleared, no item is selected, so all menu
		# options for package actions should be disabled
		self.mi_unmark.set_sensitive(False)
		self.mi_install.set_sensitive(False)
		self.mi_reinstall.set_sensitive(False)
		self.mi_remove.set_sensitive(False)
		self.mi_getinfo.set_sensitive(False)
		cmdstatus, pkglist = self.slaptsrclist(self.entry_search.get_text())
		if cmdstatus == 0:
			pkg_varlogpkg = commands.getoutput('ls /var/log/packages').splitlines()
			pkg_installed = []
			for i in pkg_varlogpkg:
				pkg_installed.append(i.rpartition('-')[0].rpartition('-')[0].rpartition('-')[0])

			for i in pkglist:
				action = 0
				pkgname, pkgver, pkgdesc = i
				for i in pending:
					if pkgname == i[0] and pkgver == i[1]:
						action = i[2]
						break
				if pkgname in pkg_installed:
					icon = Icon.installed
					installed = True
				else:	
					icon = Icon.avail
					installed = False
				if [pkgname, pkgver, PkgAction.Install] in pending:
					icon = Icon.install
					installed = False
				elif [pkgname, pkgver, PkgAction.Reinstall] in pending:
					icon = Icon.reinstall
					installed = True
				elif [pkgname, pkgver, PkgAction.Remove] in pending:
					icon = Icon.remove
					installed = True
				self.ls_pkg.append([icon, pkgname,
					pkgver, pkgdesc,
					installed, action])
		else:
			self.dlg_updateerror.show()

	def on_toolbutton_update_clicked(self, widget):
		self.window_cacheupdate.show()
		self.pbar_cacheupdate.pulse()
		process = subprocess.Popen(['slapt-src','-u'], shell=False)
		while True:
			while gtk.events_pending():
				gtk.main_iteration()
			self.pbar_cacheupdate.pulse()
			status = process.poll()
			time.sleep(0.1)
			if status != None:
				self.window_cacheupdate.hide()
				break
		if status == 0:
			self.refresh_pkglist()
		else:
			self.ls_pkg.clear()
			self.dlg_errorcache.show()

	def on_toolbutton_exec_clicked(self, widget):
		global pending
		for i in pending:
			if i[2] == PkgAction.Install:
				desc = _('%s %s is going to be installed') % (i[0], i[1])
			elif i[2] == PkgAction.Reinstall:
				desc = _('%s %s is going to be reinstalled') % (i[0], i[1])
			elif i[2] == PkgAction.Remove:
				desc = _('%s %s is going to be removed') % (i[0], i[1])
			self.ls_summary.append([desc, i[0], i[1], i[2]])
		self.dlg_summary.show()
		
	
	def on_toolbutton_clearsearch_clicked(self, widget):
		if len(self.entry_search.get_text()) != 0:
			self.entry_search.set_text(None)
			self.refresh_pkglist()

	def on_entry_search_activate(self, widget):
		self.refresh_pkglist()	

	def on_entry_search_icon_release(self, widget, icon, event):
		if icon.value_name == 'GTK_ENTRY_ICON_PRIMARY':
			if len(self.entry_search.get_text()) != 0:
				self.entry_search.set_text('')
				while gtk.events_pending():
					gtk.main_iteration()
		self.refresh_pkglist()

	def update_menus(self):
		global pending
		global pkg_varlogpkg
		selectedline = self.tv_pkg.get_selection()
		self.ls_pkg, iter = selectedline.get_selected()
		pkg = self.ls_pkg.get_value(iter, 1)
		ver = self.ls_pkg.get_value(iter, 2)
		installed = self.ls_pkg.get_value(iter, 4)
		action = self.ls_pkg.get_value(iter, 5)
		pkg_installed = []
		for i in pkg_varlogpkg:
			pkg_installed.append(i.rpartition('-')[0].rpartition('-')[0].rpartition('-')[0])
		if installed:
			self.mi_install.set_sensitive(False)
			self.mi_pkg_install.hide()
			self.mi_reinstall.set_sensitive(True)
			self.mi_pkg_reinstall.show()
			self.mi_remove.set_sensitive(True)
			self.mi_pkg_remove.show()
			self.mi_getinfo.set_sensitive(True)
		else:
			self.mi_install.set_sensitive(True)
			self.mi_pkg_install.show()
			self.mi_reinstall.set_sensitive(False)
			self.mi_pkg_reinstall.hide()
			self.mi_remove.set_sensitive(False)
			self.mi_pkg_remove.hide()
			self.mi_getinfo.set_sensitive(True)
		if action == PkgAction.DoNothing:
			self.mi_unmark.set_sensitive(False)
			self.mi_pkg_unmark.hide()
			if [pkg, ver, PkgAction.Install] in pending:
				pending.remove([pkg, ver, PkgAction.Install])
			if [pkg, ver, PkgAction.Reinstall] in pending:
				pending.remove([pkg, ver, PkgAction.Reinstall])
			if [pkg, ver, PkgAction.Remove] in pending:
				pending.remove([pkg, ver, PkgAction.Remove])
			if pkg in pkg_installed:
				self.ls_pkg.set_value(iter, 0, Icon.installed)
			else:
				self.ls_pkg.set_value(iter, 0, Icon.avail)
		elif action == PkgAction.Install:
			self.mi_unmark.set_sensitive(True)
			self.mi_pkg_unmark.show()
			self.mi_install.set_sensitive(False)
			self.mi_pkg_install.hide()
			if [pkg, ver, PkgAction.Install] in pending:
				pass
			else:
				pending.append([pkg, ver, PkgAction.Install])
			self.ls_pkg.set_value(iter, 0, Icon.install)
		elif action == PkgAction.Reinstall:
			self.mi_unmark.set_sensitive(True)
			self.mi_pkg_unmark.show()
			self.mi_reinstall.set_sensitive(False)
			self.mi_pkg_reinstall.hide()
			if [pkg, ver, PkgAction.Reinstall] in pending:
				pass
			else:
				pending.append([pkg, ver, PkgAction.Reinstall])
			if [pkg, ver, PkgAction.Remove] in pending:
				pending.remove([pkg, ver, PkgAction.Remove])
			self.ls_pkg.set_value(iter, 0, Icon.reinstall)
		elif action == PkgAction.Remove:
			self.mi_unmark.set_sensitive(True)
			self.mi_pkg_unmark.show()
			self.mi_remove.set_sensitive(False)
			self.mi_pkg_remove.hide()
			if [pkg, ver, PkgAction.Remove] in pending:
				pass
			else:
				pending.append([pkg, ver, PkgAction.Remove])
			if [pkg, ver, PkgAction.Reinstall] in pending:
				pending.remove([pkg, ver, PkgAction.Reinstall])
			self.ls_pkg.set_value(iter, 0, Icon.remove)
		if pending == []:
			self.mi_unmarkall.set_sensitive(False)
			self.tb_exec.set_sensitive(False)
			self.mi_exec.set_sensitive(False)
		else:
			self.mi_unmarkall.set_sensitive(True)
			self.tb_exec.set_sensitive(True)
			self.mi_exec.set_sensitive(True)

	def on_treeview_pkg_button_press_event(self, widget, event):
		x = int(event.x)
		y = int(event.y)
		time = event.time
		pthinfo = self.tv_pkg.get_path_at_pos(x,y)
		if pthinfo is not None:
			path, col, cellx , celly = pthinfo
			self.tv_pkg.grab_focus()
			self.tv_pkg.set_cursor(path, col, 0)
			self.update_menus()
			if col.get_title() == _('Status') or event.button == 3:
				self.menu_pkgaction.popup(None, None, None, event.button, time)
		return True
	
	def on_menuitem_unmarkall_activate(self, widget):
		global pending
		pending = []
		self.mi_unmarkall.set_sensitive(False)
		self.tb_exec.set_sensitive(False)
		self.mi_exec.set_sensitive(False)
		self.refresh_pkglist()

	def on_menuitem_unmark_activate(self, widget):
		selectedline = self.tv_pkg.get_selection()
		self.ls_pkg, iter = selectedline.get_selected()
		self.ls_pkg.set_value(iter, 5, PkgAction.DoNothing)
		self.update_menus()
	
	def on_menuitem_install_activate(self, widget):
		selectedline = self.tv_pkg.get_selection()
		self.ls_pkg, iter = selectedline.get_selected()
		self.ls_pkg.set_value(iter, 5, PkgAction.Install)
		self.update_menus()

	def on_menuitem_reinstall_activate(self, widget):
		selectedline = self.tv_pkg.get_selection()
		self.ls_pkg, iter = selectedline.get_selected()
		self.ls_pkg.set_value(iter, 5, PkgAction.Reinstall)
		self.update_menus()

	def on_menuitem_remove_activate(self, widget):
		selectedline = self.tv_pkg.get_selection()
		self.ls_pkg, iter = selectedline.get_selected()
		self.ls_pkg.set_value(iter, 5, PkgAction.Remove)
		self.update_menus()
	
	def on_menuitem_getinfo_activate(self, widget):
		selectedline = self.tv_pkg.get_selection()
		self.ls_pkg, iter = selectedline.get_selected()
		pkg = self.ls_pkg.get_value(iter, 1)
		ver = self.ls_pkg.get_value(iter, 2)
		print 'Get info for: ', pkg, ver

	def on_dialog_errorcache_delete_event(self, widget, event):
		self.dlg_errorcache.hide()
		return True

	def on_button_errorcache_close_clicked(self, widget):
		self.dlg_errorcache.hide()

	def on_dialog_summary_delete_event(self, widget, event):
		self.dlg_summary.hide()
		self.ls_summary.clear()
		return True

	def on_button_summary_apply_clicked(self, widget):
		self.dlg_summary.hide()
		self.dlg_exec.show()
		self.execute_pending()

	def installpkg(self, pkg, pkgver):
		global canceltask
		canceltask = False
		process = subprocess.Popen(['slapt-src','-y','-i', pkg+':'+pkgver], shell=False, close_fds=True, preexec_fn=os.setsid)
		while not canceltask:
			while gtk.events_pending():
				gtk.main_iteration()
			self.pb_exec.pulse()
			status = process.poll()
			time.sleep(0.1)
			if status != None:
				break
		if status == None:
			os.killpg(process.pid, signal.SIGKILL)
		if canceltask:
			canceltask = False
			return 1
		else:
			canceltask = False
			return 0

	def removepkg(self, pkg):
		error = False
		process = subprocess.Popen(['slapt-get', '-y', '--remove', '--no-dep', pkg], shell=False)
		while True:
			while gtk.events_pending():
				gtk.main_iteration()
			self.pb_exec.pulse()
			status = process.poll()
			time.sleep(0.1)
			if status != None:
				break
		if error:
			return 1
		else:
			return 0

	def execute_pending(self):
		global pending
		while gtk.events_pending():
			gtk.main_iteration()
		totaltasks = len(self.ls_summary)
		currentpos = 0
		step = 1/float(totaltasks)
		self.pb_execoverall.set_fraction(0)
		self.pb_exec.set_fraction(0)
		for i in self.ls_summary:
			if i[3] == PkgAction.Install:
				self.lb_exec.set_text(_('Installing')+' '+i[1]+'-'+i[2]+'...')
				retval = self.installpkg(i[1], i[2])
			if i[3] == PkgAction.Reinstall:
				self.lb_exec.set_text(_('Reinstalling')+' '+i[1]+'-'+i[2]+'...')
				retval = self.installpkg(i[1], i[2])
			if i[3] == PkgAction.Remove:
				self.lb_exec.set_text(_('Removing')+' '+i[1]+'...')
				retval = self.removepkg(i[1])
			currentpos = currentpos + step
			self.pb_execoverall.set_fraction(currentpos)
		pending = []
		self.ls_summary.clear()
		self.refresh_pkglist()
		self.dlg_exec.hide()
		if retval == 0:
			self.dlg_success.show()
		else:
			self.dlg_canceled.show()

	def on_button_summary_cancel_clicked(self, widget):
		self.ls_summary.clear()
		self.dlg_summary.hide()

	def on_button_exec_cancel_clicked(self, widget):
		# nothing much here, I don't know how to stop the
		# slapt-src child process of running foo.SlackBuild
		# slapt-src itself can be stopped with process.kill(),
		# but the child process will keep running
		global canceltask
		canceltask = True
		self.dlg_exec.hide()

	def on_button_success_ok_clicked(self, widget):
		self.dlg_success.hide()

	def on_button_canceled_ok_clicked(self, widget):
		self.dlg_canceled.hide()
	
	def on_button_updateerror_ok_clicked(self, widget):
		self.dlg_updateerror.hide()
	
	def gtk_main_quit(self, widget, data=None):
		gtk.main_quit()

	def __init__(self):
		builder = gtk.Builder()
		if os.path.exists('gslackbuild.glade'):
			builder.add_from_file('gslackbuild.glade')
		elif os.path.exists('/usr/share/salixtools/gslackbuild/gslackbuild.glade'):
			builder.add_from_file('/usr/share/salixtools/gslackbuild/gslackbuild.glade')

		#
		# Main window objects
		#
		self.window = builder.get_object('gslackbuild')
		self.tv_pkg = builder.get_object('treeview_pkg')
		self.tv_pkg.set_rules_hint(True)
		self.tvc_status = builder.get_object('treeviewcolumn_status')
		self.tvc_status.set_title(_('Status'))
		self.cr_status = builder.get_object('cellrendererpixbuf_status')
		self.tvc_pkgname = builder.get_object('treeviewcolumn_pkgname')
		self.tvc_pkgname.set_title(_('Name'))
		self.tvc_version = builder.get_object('treeviewcolumn_version')
		self.tvc_version.set_title(_('Version'))
		self.tvc_desc = builder.get_object('treeviewcolumn_desc')
		self.tvc_desc.set_title(_('Description'))
		self.ls_pkg = builder.get_object('liststore_pkg')
		self.tb_update = builder.get_object('toolbutton_update')
		self.tb_exec = builder.get_object('toolbutton_exec')
		self.entry_search = builder.get_object('entry_search')
		# File menu
		self.mi_exec = builder.get_object('menuitem_exec')
		# Edit menu
		self.mi_unmarkall = builder.get_object('menuitem_unmarkall')
		# Package menu
		self.mi_unmark = builder.get_object('menuitem_unmark')
		self.mi_install = builder.get_object('menuitem_install')
		self.mi_reinstall = builder.get_object('menuitem_reinstall')
		self.mi_remove = builder.get_object('menuitem_remove')
		self.mi_getinfo = builder.get_object('menuitem_getinfo')
		# right click menu
		self.menu_pkgaction = builder.get_object('menu_pkgaction')
		self.mi_pkg_unmark = builder.get_object('menuitem_pkg_unmark')
		self.mi_pkg_install = builder.get_object('menuitem_pkg_install')
		self.mi_pkg_reinstall = builder.get_object('menuitem_pkg_reinstall')
		self.mi_pkg_remove = builder.get_object('menuitem_pkg_remove')
		self.mi_pkg_getinfo = builder.get_object('menuitem_pkg_getinfo')

		#
		# Update cache progress window
		#
		self.window_cacheupdate = builder.get_object('window_cacheupdate')
		self.pbar_cacheupdate = builder.get_object('progressbar_cacheupdate')

		#
		# Error updating cache dialog
		#
		self.dlg_errorcache = builder.get_object('dialog_errorcache')
		self.btn_errorcacheok = builder.get_object('button_errorcacheok')

		#
		# Summary dialog
		#
		self.dlg_summary = builder.get_object('dialog_summary')
		self.btn_summary_apply = builder.get_object('button_summary_apply')
		self.btn_summary_cancel = builder.get_object('button_summary_cancel')
		self.tv_summary = builder.get_object('treeview_summary')
		self.ls_summary = builder.get_object('liststore_summary')

		#
		# Execute dialog
		#
		self.dlg_exec = builder.get_object('dialog_exec')
		self.btn_exec_cancel = builder.get_object('button_exec_cancel')
		self.lb_exec = builder.get_object('label_exec')
		self.pb_exec = builder.get_object('progressbar_exec')
		self.tv_exec = builder.get_object('treeview_exec')
		self.pb_execoverall = builder.get_object('progressbar_execoverall')


		#
		# Success dialog
		#
		self.dlg_success = builder.get_object('messagedialog_success')
		self.btn_success_ok = builder.get_object('button_success_ok')

		#
		# Canceled tasks dialog
		#
		self.dlg_canceled = builder.get_object('messagedialog_canceled')
		self.btn_canceled_ok = builder.get_object('button_canceled_ok')

		#
		# Update error dialog
		#
		self.dlg_updateerror = builder.get_object('messagedialog_updateerror')
		self.btn_updateerror_ok = builder.get_object('button_updateerror_ok')

		global pending
		pending = []
		global pkg_varlogpkg	
		pkg_varlogpkg = commands.getoutput('ls /var/log/packages').splitlines()
		
		# Connect all signals
		builder.connect_signals(self)
		self.refresh_pkglist()

if __name__ == "__main__":
	app = GSlackBuild()
	app.window.show()
	gtk.main()
